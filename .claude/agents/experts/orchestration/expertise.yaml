# Workflow Orchestration Expertise
# Target: 600-700 lines | Domain: Operational knowledge for multi-agent coordination

overview:
  description: |
    Workflow orchestration for multi-agent systems—single-message parallelism,
    dependency batching, phase gating, spec-as-artifact pattern, and coordinator
    vs worker tool sets. This expertise enables efficient parallel execution and
    clean workflow coordination.
  scope: |
    Covers Task tool parallelism patterns, dependency management, orchestrator
    design, spec file patterns, and tool selection by role. Does NOT cover
    general scheduling or traditional workflow engines. Focuses on Claude Code
    and SDK-level orchestration patterns.
  rationale: |
    Poor orchestration leads to sequential bottlenecks, race conditions, and
    fragile workflows. Correct parallelism patterns dramatically reduce latency.
    Single-message parallelism is the make-or-break pattern most practitioners miss.

core_implementation:
  primary_files:
    - path: .claude/commands/do.md
      purpose: Direct orchestration of expert agents - plan→approval→build→improve pattern
    - path: .claude/skills/orchestrating-knowledge-workflows/SKILL.md
      purpose: Workflow templates (formerly coordinators, converted to skills in commit 353d576)
    - path: chapters/6-patterns/3-orchestrator-pattern.md
      purpose: Orchestrator pattern documentation with single-message parallelism
    - path: chapters/7-practices/5-workflow-coordination.md
      purpose: Workflow coordination practices

  key_sections:
    - name: Single-Message Parallelism
      location: chapters/6-patterns/3-orchestrator-pattern.md#single-message-parallelism
      summary: CRITICAL pattern - all parallel Task calls in ONE message
    - name: Context Isolation via Sub-Agents
      location: chapters/6-patterns/3-orchestrator-pattern.md#context-isolation-via-sub-agents
      summary: Why delegation maintains clean orchestrator context
    - name: Capability Minimization
      location: chapters/6-patterns/3-orchestrator-pattern.md#capability-minimization
      summary: Tool restriction patterns for subagents

key_operations:
  single_message_parallelism:
    name: Execute Independent Tasks in Parallel (Single Message)
    description: Run all non-dependent Task calls in ONE message for true concurrency
    when_to_use: CRITICAL - Multiple independent operations needed
    approach: |
      1. Identify independent operations (no data dependencies between them)
      2. Make ALL Task calls in a single response message
      3. Wait for ALL to complete before proceeding
      4. NEVER split into multiple messages unless dependencies exist

      Why: 10 agents in parallel ≈ 1 agent time vs 10× longer if serialized
    examples:
      - scenario: Research spawning 3 independent workers
        implementation: "Task(docs), Task(blogs), Task(examples) in ONE message"
      - scenario: Sequential plan→build (dependency exists)
        implementation: "Message 1: Task(plan). Wait. Message 2: Task(build)"

  dependency_batching:
    name: Batch Operations by Dependency Layer
    description: Group operations that can run together, gate on dependencies
    when_to_use: Complex workflows with partial dependencies
    approach: |
      1. Map dependency graph
      2. Identify layers (L0: no deps, L1: depends on L0, etc.)
      3. Execute each layer in single message (parallel within layer)
      4. Wait for layer completion before next layer
    examples:
      - scenario: Parallel scouts → synthesis → parallel builds
        layers: "L0: [scout-a, scout-b, scout-c]. L1: [synth]. L2: [build-1, build-2]"

  spec_as_artifact:
    name: Write Spec File, Workers Read It
    description: Coordinator writes spec to file, spawned agents read it
    when_to_use: Passing complex context between agents
    approach: |
      1. Coordinator writes spec to .claude/.cache/specs/<domain>/<slug>.md
      2. Spawns worker with: Task(build-agent, "PATH_TO_SPEC: <path>")
      3. Worker reads spec file (not passed inline)

      Benefits: Decouples spec from execution, enables resume, auditable artifact
    examples:
      - scenario: Knowledge plan→build flow
        implementation: "Plan writes spec. Spawns: Task(build, PATH_TO_SPEC)"

  context_isolation:
    name: Use Sub-Agents for Context Hygiene
    description: Deploy fresh context windows for search/analysis operations
    when_to_use: Orchestrator needs synthesized information, not raw data
    approach: |
      Sub-agents absorb raw data, return summaries:
      - Scout: "Found 47 files in 3 modules" (not 47 paths)
      - Grep: "Pattern in 12 locations, primarily validation" (not 12 matches)

      Mental model: Sub-agents are expensive, disposable context buffers
    examples:
      - scenario: Orchestrator needs codebase overview
        implementation: "Task(scout). Scout absorbs paths. Returns: synthesis only."

decision_trees:
  architecture_decision:
    name: Flat vs Nested Orchestration
    entry_point: How many orchestration layers needed?
    branches:
      - condition: Entry point needs multi-phase workflow
        action: Flat - entry point spawns workers directly
        rationale: Avoids nested subagent limitation (agent→Task→agent→Task unreliable)
      - condition: Need reusable workflow templates
        action: Create skill (not coordinator agent)
        rationale: Skills provide templates without spawning complexity
      - condition: Multiple independent workers
        action: Spawn all in parallel from entry point (single message)
    evidence: commit 353d576 - flatten architecture
    timestamp: 2025-12-26

  parallelism_decision:
    name: Parallelism Decision Tree
    entry_point: Are operations independent?
    branches:
      - condition: No dependencies
        action: ALL Task calls in ONE message
      - condition: Operation B depends on A
        action: "Msg 1: Task(A). Wait. Msg 2: Task(B)"
      - condition: Complex dependency graph
        action: Batch by layer, one message per layer

  tool_selection_by_role:
    name: Tool Selection for Agent Role
    entry_point: What is the agent's primary function?
    branches:
      - condition: Coordination/orchestration
        action: Task, Read, Grep, Glob, AskUserQuestion (NO Write)
      - condition: Implementation/building
        action: Read, Write, Edit, Grep, Glob (NO Task)
      - condition: Exploration/scouting
        action: Read, Glob, Grep only (read-only)

patterns:
  flat_orchestration_pattern:
    name: Flat Orchestration (Direct Expert Agent Spawning)
    context: Avoiding nested subagent limitations by flattening hierarchy
    implementation: |
      OLD (nested, broken): /do → coordinator → expert (Task→Task)
      NEW (flat, working): /do → expert (single Task layer)

      /do directly orchestrates: classify → spawn plan → approve → spawn build → spawn improve
    evidence: commit 353d576 - deleted .claude/agents/coordinators/
    timestamp: 2025-12-26

  fan_out_fan_in:
    name: Fan-Out Fan-In (Parallel Workers, Single Aggregator)
    context: Multiple independent workers, aggregate results
    implementation: |
      1. Fan-out: Spawn N workers in single message
      2. Wait: All workers complete
      3. Fan-in: Aggregate into unified output
    real_examples:
      - location: .claude/skills/researching-external-sources/SKILL.md
        note: Spawn 3 parallel researchers

  phase_gating_pattern:
    name: Phase Gating (Plan → Approve → Build → Review)
    context: Workflows requiring human approval between phases
    implementation: |
      1. Spawn plan → wait for spec
      2. AskUserQuestion("Approve?") → gate
      3. Spawn build with spec path
      4. Spawn improve if changes made
    evidence: .claude/commands/do.md lines 139-144
    timestamp: 2025-12-26

  4_agent_domain_pattern:
    name: 4-Agent Domain Expert Pattern (Plan/Build/Improve/Question)
    context: Organizing domain expertise into standardized agent roles
    implementation: |
      Each expert domain gets 4 specialized agents:
      1. plan-agent: Creates specs → .claude/.cache/specs/<domain>/
      2. build-agent: Implements from spec (NO Task tool)
      3. improve-agent: Learns from changes, updates expertise.yaml
      4. question-agent: Answers domain questions

      In flat architecture: /do spawns plan→build→improve directly (no coordinator layer)
    real_examples:
      - location: .claude/agents/experts/knowledge/
        note: Full 4-agent pattern
      - location: .claude/agents/experts/github/
        note: Added in commit 35a871a
    timestamp: 2025-12-26

cross_domain_inheritance: []

best_practices:
  - category: Architecture
    practices:
      - practice: Prefer flat orchestration - entry point spawns workers directly
        evidence: commit 353d576 - flatten to avoid nested subagent issues
        timestamp: 2025-12-26
      - practice: Convert coordinators to skills (workflow templates)
        evidence: .claude/skills/*-workflows/ - former coordinators
        timestamp: 2025-12-26
      - practice: Standardize color assignments (plan=yellow, build=green, improve=purple, question=cyan)
        evidence: commit 89fbbf9 - 49 agents across 12 domains
        timestamp: 2025-12-26
      - practice: Use /do as universal orchestrator (not multiple coordinators)
        evidence: commit 353d576 - single orchestration point
        timestamp: 2025-12-26
      - practice: NEVER use colons in agent description frontmatter (Expects USER_PROMPT, not Expects colon USER_PROMPT)
        evidence: commit b6a2b47 - fixed 38 agents silently failing discovery due to colon
        rationale: Colons in description values cause silent agent discovery failures
        timestamp: 2026-01-17

  - category: Parallelism
    practices:
      - practice: CRITICAL - All independent Task calls in ONE message
        evidence: chapters/6-patterns/3-orchestrator-pattern.md
        timestamp: 2025-12-26
      - practice: Wait for layer completion before next dependency layer
        evidence: .claude/commands/do.md sequential phase execution
        timestamp: 2025-12-26

  - category: Tool Selection
    practices:
      - practice: Entry orchestrators get Task + Read + Grep + Glob + AskUserQuestion (no Write)
        note: Orchestrators delegate implementation
      - practice: Workers get Read + Write + Edit + Grep + Glob (no Task)
        note: Workers implement, don't spawn - prevents nested issues
      - practice: Scouts get Read + Glob + Grep only (read-only)
      - practice: Plan agents get Read + Write + Grep + Glob (Write for spec caching only)
      - practice: Operational agents (git, deployment) need Bash for commands
        evidence: github-build-agent.md uses Bash with safety protocols
        timestamp: 2025-12-26
      - practice: Improve agents get Bash for usage analysis (git log, gh pr list)
        evidence: github-improve-agent.md analyzes git history
        timestamp: 2025-12-26

  - category: Spec Patterns
    practices:
      - practice: Spec files in .claude/.cache/specs/<domain>/
      - practice: Pass file path to worker, not spec content inline
      - practice: Spec enables resume with --build-only flag

  - category: Context Hygiene
    practices:
      - practice: Sub-agents return synthesis, not raw output
      - practice: Orchestrator context should contain summaries, not raw data

  - category: Expertise Governance
    practices:
      - practice: Enforce expertise.yaml size limits - HARD LIMIT 1000 lines, TARGET 750, WARNING 900
        evidence: commit cb89c17 - pruned 12 domains from 10,425→6,537 lines (-37%)
        rationale: Prevents unbounded accumulation, degraded maintainability, duplicate patterns
        timestamp: 2025-12-28
      - practice: Prune tactical entries >14 days old when approaching size limits
        evidence: Cross-domain pattern expertise-size-governance
        timestamp: 2025-12-28
      - practice: Consolidate duplicate patterns and reduce examples to 2-3 max
        evidence: orchestration domain pruned from 940→464 lines in cb89c17
        timestamp: 2025-12-28

  - category: Error Handling
    practices:
      - practice: Graceful degradation - continue with available analyses if expert fails
        evidence: chapters/6-patterns/3-orchestrator-pattern.md#error-handling
        timestamp: 2025-12-26
      - practice: Commit successful changes before reporting failures
      - practice: Isolated failure in parallel execution (one failure doesn't cascade)
        evidence: research-coordinator-agent.md lines 502-506
        timestamp: 2025-12-26
      - practice: Improve stage is optional - workflow succeeds if build succeeds
        timestamp: 2025-12-26

  - category: Sequential vs Parallel Coordination
    practices:
      - practice: Plan→Build→Improve runs sequentially (dependency chain)
        evidence: .claude/commands/do.md lines 134-158
        timestamp: 2025-12-26
      - practice: Multi-source research runs in parallel (fan-out/fan-in)
        evidence: .claude/skills/researching-external-sources/SKILL.md
        timestamp: 2025-12-26
      - practice: Always wait for Task completion before proceeding
        evidence: .claude/commands/do.md Rule 3 (lines 110-126)
        timestamp: 2025-12-26

  - category: Expert Swarm Coordination
    practices:
      - practice: Pass expertise.yaml path to workers (not content) via EXPERTISE_PATH parameter
        evidence: chapters/6-patterns/8-expert-swarm-pattern.md#expertise-inheritance-protocol
        rationale: Prevents context bloat (750 lines copied = 3K tokens per worker), maintains single source of truth
        timestamp: 2026-02-02
      - practice: Enforce learning separation - workers read-only, improve agent updates expertise post-swarm
        evidence: chapters/6-patterns/8-expert-swarm-pattern.md#learning-separation
        rationale: Prevents race conditions when multiple workers try updating expertise simultaneously
        timestamp: 2026-02-02
      - practice: Spawn all parallel workers in single message for true concurrency
        evidence: Expert Swarm Pattern commit 20500f1 - 10 workers in one message = 10× speedup
        timestamp: 2026-02-02
      - practice: Workers return summaries, not full artifacts, to orchestrator
        evidence: chapters/6-patterns/8-expert-swarm-pattern.md#orchestrator-context-hygiene
        rationale: Keeps orchestrator context available for synthesis decisions
        timestamp: 2026-02-02
      - practice: Target 750-line expertise.yaml maximum for swarm-inherited expertise
        evidence: chapters/6-patterns/8-expert-swarm-pattern.md#size-governance
        rationale: Token economics - 750 lines = 3K tokens per worker (manageable), 2K lines = 8K tokens (unsustainable)
        timestamp: 2026-02-02

  - category: Canonical Swarm Prompting
    practices:
      - practice: Use canonical prompt structure (ROLE/CONTEXT/TASK/CONSTRAINTS/OUTPUT) for all teammates
        evidence: .claude/commands/do-swarm.md#teammate-prompting-format
        rationale: Reduces variance - 10-agent swarm with canonical format showed zero voice drift vs 15-20% without
        timestamp: 2026-02-02
      - practice: Avoid negative constraints ("Never X") - use positive alternatives ("Do Y")
        evidence: .claude/commands/do-swarm.md#forbidden-patterns
        rationale: Pink elephant effect - negative constraints focus model attention on prohibited action
        timestamp: 2026-02-02
      - practice: Specify validation level explicitly (Quick/Standard/Critical)
        evidence: .claude/commands/do-swarm.md#validation-levels
        rationale: Prevents inconsistent quality across parallel workers
        timestamp: 2026-02-02
      - practice: End prompts with "Use this exact format. No preamble." to prevent meta-commentary
        evidence: .claude/commands/do-swarm.md#output-consistency-enforcement
        timestamp: 2026-02-02

  - category: /do vs /do-swarm Selection
    practices:
      - practice: Use /do for sequential workflows (plan→build→improve), simple delegation
        evidence: .claude/commands/do.md + .claude/commands/do-swarm.md
        timestamp: 2026-02-02
      - practice: Use /do-swarm for parallel coordination with inter-agent messaging, multiple experts
        evidence: .claude/commands/do-swarm.md
        timestamp: 2026-02-02
      - practice: /do-swarm requires TeammateTool access (server-side gated, requires CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1)
        evidence: .claude/commands/do-swarm.md#requirements
        timestamp: 2026-02-02
      - practice: For quick research swarms, skip shutdown ceremony (teammates timeout naturally ~5 min)
        evidence: .claude/commands/do-swarm.md#cleanup
        rationale: Saves 3-4 conversation turns without downside
        timestamp: 2026-02-02

anti_patterns:
  frontmatter_colon_usage:
    name: Using Colons in Agent Description Frontmatter Values
    why_problematic: |
      Colons in YAML frontmatter values cause silent parsing failures.

      Common pattern: "description: Plans X. Expects: USER_PROMPT"
      Problem: Second colon breaks YAML parsing → agent not discovered
      Detection: Agent file exists but Claude Code can't spawn it (silent failure)

      Blast radius: Affects ALL agents with this pattern (38 in b6a2b47)
      Impact: Workflows break silently, users assume agents don't exist
    resolution: |
      Remove ALL colons from frontmatter values:
      - BEFORE: "Expects: USER_PROMPT"
      - AFTER: "Expects USER_PROMPT"

      Detection command: grep -r "description:.*Expects:" .claude/agents/
      Validation: Claude Code agent discovery test
    evidence: commit b6a2b47 - 38 agents fixed
    timestamp: 2026-01-17

  coordinator_proliferation:
    name: Creating Specialized Coordinator per Workflow Type
    why_problematic: |
      Deprecated pattern: Create separate coordinator agents (book, knowledge, research, review).

      Problems:
      1. Nested subagent spawning unreliable (coordinator→Task→expert broken)
      2. Coordinator logic duplicates across workflows
      3. Hard to discover which coordinator to use
      4. Each coordinator adds 300-600 lines
      5. Inconsistent approval gates
    resolution: |
      Flatten to single /do orchestrator:
      - /do classifies → routes to domain
      - /do orchestrates plan→approve→build→improve directly
      - Workflows become skills (templates, not agents)

      Result: 4 coordinators (1847 lines) → 1 orchestrator (710 lines) + 4 skill templates
    evidence: commit 353d576 - deleted .claude/agents/coordinators/
    timestamp: 2025-12-26

  accidental_serialization:
    name: Splitting Independent Task Calls Across Messages
    why_problematic: |
      Most common error: Spawn 3 independent agents across 3 messages.
      Result: Sequential execution (3× latency) instead of parallel (1× latency).
    resolution: |
      CRITICAL discipline - all independent Task calls in ONE message:
      Task(researcher-a), Task(researcher-b), Task(researcher-c) in same response
    evidence: chapters/6-patterns/3-orchestrator-pattern.md lines 39-56
    timestamp: 2025-12-26

  premature_exit_in_async_contexts:
    name: Not Waiting for Task Completion Before Reporting
    why_problematic: |
      In --print mode and async contexts, exiting before subagents complete loses work.
      User sees "complete" but no results.
    resolution: |
      Always wait for Task completion → extract outputs → synthesize → report
      Rule: Wait → Collect → Synthesize → Report (never exit early)
    evidence: .claude/commands/do.md Rule 3 (lines 110-126)
    timestamp: 2025-12-26

known_issues:
  - issue: Nested subagent spawning (agent→Task→agent→Task) unreliable
    workaround: Flatten architecture - top-level command orchestrates directly
    status: architectural-limitation (resolved via flatten pattern)
    timestamp: 2025-12-26
    evidence: commit 353d576

  - issue: Task tool parallelism requires single message discipline
    workaround: Explicit instruction in prompts to emit all parallel calls in one response
    status: open
    timestamp: 2025-12-26

  - issue: Spec file cleanup not automated
    workaround: Manual cleanup or periodic purge of .claude/.cache/specs/
    status: open
    timestamp: 2025-12-26

  - issue: CLI-level tool restrictions apply uniformly
    workaround: Explicit tool declarations in frontmatter, behavioral enforcement via prompts
    status: documented-limitation
    timestamp: 2025-12-26

patterns_discovered_in_recent_work:
  agent_description_frontmatter_safety:
    name: Agent Description Frontmatter Safety (Colon Prohibition)
    context: Preventing silent agent discovery failures
    discovered: 2026-01-17 (commit b6a2b47)
    implementation: |
      Agent frontmatter description field MUST NOT contain colons in values.

      INCORRECT: "description: Plans X. Expects: USER_PROMPT"
      CORRECT: "description: Plans X. Expects USER_PROMPT"

      Rationale: Colons in description values cause YAML parsing errors that
      fail silently - agent files exist but Claude Code can't discover them.

      Detection: Check all agent files with grep for "description:.*Expects:"
      Fix: Remove colons after "Expects", use spaces instead

      Applies to: ALL agent frontmatter fields (description, tools, model, etc.)

      Blast radius: 38 agents across 12 expert domains affected in b6a2b47
    evidence: commit b6a2b47 - 38 agent files fixed simultaneously
    timestamp: 2026-01-17

  orchestration_trace_logging_pattern:
    name: Orchestration Execution Trace Logging
    context: Observability for self-improving orchestration (ELA Component 2)
    discovered: 2025-12-27
    implementation: |
      PostToolUse hook captures execution traces when Task tool invoked.

      Data captured per Task:
      - Agent metadata: name, type, file path, phase, domain
      - Execution metrics: latency_ms, success/failure, error_type
      - Context metrics: context_tokens, output_tokens, total_tokens
      - Hierarchy: session_id, parent_session_id, agent_depth
      - Orchestration: spec_path, description

      Output: .claude/.cache/orchestration-traces.jsonl (append-only)

      Analysis opportunities:
      - Single-message parallelism adherence (count concurrent Task calls)
      - Phase timing distribution (plan_avg_ms, build_avg_ms, improve_avg_ms)
      - Approval gate effectiveness (rejection rate)
      - Context pollution trends (orchestrator context size growth)

      Enables: do-management-improve-agent to analyze /do routing strategy
    evidence: .claude/hooks/orchestration_trace_logger.py - 273 lines
    timestamp: 2025-12-27

  cross_domain_learning_registry_pattern:
    name: Cross-Domain Expertise Propagation via Shared Registry
    context: Enable pattern sharing across 12 expert domains (ELA Component 3)
    discovered: 2025-12-27
    implementation: |
      Shared registry at .claude/agents/experts/.shared/observations.yaml

      Structure:
      - cross_domain_patterns: pattern name, source, observation, applicability, evidence
      - failed_adoptions: pattern, attempted_in, reason, lesson

      Contribution protocol:
      1. After updating domain expertise.yaml
      2. Check: Does this pattern apply beyond this domain?
      3. If yes: Append to observations.yaml with applicability list
      4. If failed: Document why, extract meta-learning

      Governance: Decentralized - any improve agent can contribute
      Validation: Domains mark patterns as validated via cross_domain_inheritance
    evidence: .claude/agents/experts/.shared/observations.yaml - 138 lines
    timestamp: 2025-12-27

  color_standardization_pattern:
    name: Semantic Color Coding for 4-Agent Expert Domains
    context: Visual discoverability across all expert domains
    discovered: 2025-12-26 (commit 89fbbf9)
    implementation: |
      Consistent color scheme:
      - plan-agent: yellow (analysis)
      - build-agent: green (creation)
      - improve-agent: purple (review)
      - question-agent: cyan (advisory)

      Applied to 49 agents across 12 domains.
      Visual benefit: Instant role identification by color.
    adoption: Apply to all future expert domains
    timestamp: 2025-12-26

  universal_orchestrator_pattern:
    name: Universal /do Command (Single Orchestration Point)
    context: Eliminating coordinator proliferation
    discovered: 2025-12-26 (commit 353d576)
    implementation: |
      /do handles all orchestration:
      1. Classify requirement → identify domain
      2. Route to expert domain agents
      3. Orchestrate plan→approve→build→improve
      4. Handle approval gates via AskUserQuestion
      5. Synthesize results

      Deleted 4 specialized coordinators, converted to skills.
    evidence: commit 353d576 - deleted .claude/agents/coordinators/
    timestamp: 2025-12-26

  approval_gate_pattern:
    name: User Approval Between Plan and Build
    context: Preventing unwanted implementations via explicit checkpoints
    discovered: 2025-12-26
    implementation: |
      Plan creates spec → /do shows spec path → user approves → build executes.

      Using AskUserQuestion at /do level:
      - If user declines: Report spec location, suggest resume later
      - If plan fails: Report error, cannot proceed
      - If build fails: Preserve spec for retry, skip improve
    evidence: .claude/commands/do.md lines 139-148
    adoption: All implementation workflows should include approval gates
    timestamp: 2025-12-26

  delta_based_monitoring_pattern:
    name: Delta-Based Changelog Monitoring
    context: Efficient external dependency tracking without redundant re-analysis
    discovered: 2026-01-11 (commit d69ef22)
    implementation: |
      Monitor external changelog updates via state tracking for delta fetch:

      State File: .claude/.cache/changelog-state/<source>.json
      Schema: {source, last_version, last_checked, url, notes}

      Workflow:
      1. Check state file existence
      2. If missing: Full fetch (baseline)
      3. If present: Delta fetch (versions > last_version)
      4. Analyze changes: features, breaking changes, security
      5. Map cross-domain impact (which chapters/config affected)
      6. Update state file with latest version

      Orchestration Layer: /do routes to research-build-agent
      Cross-domain impact: Single changelog → multiple expert domains
      Example: Claude Code 2.1.0-2.1.4 → 7 updates across 3 chapters

      Enables: Proactive book/config updates without manual tracking
    evidence: commit d69ef22 - Claude Code 2.1.5-2.1.9 sync via state file
    real_examples:
      - location: .claude/.cache/changelog-state/claude-code.json
        note: Tracks version progression for delta fetch
    timestamp: 2026-01-11

  swarm_orchestration_pattern:
    name: Model-Native Swarm Orchestration vs SDK Orchestration
    context: Two architectural approaches to multi-agent coordination
    discovered: 2026-01-30 (commit de68e9f)
    implementation: |
      Orchestration can happen at two different layers:

      **SDK Orchestration (Claude Code, LangGraph, AutoGen):**
      - Coordination logic in external framework code
      - Explicit Task/API calls to spawn subagents
      - Framework handles waiting, synthesis, error handling
      - Developer writes coordination code
      - Example: /do spawns plan→build→improve via Task calls

      **Model-Native Swarm (Kimi K2.5):**
      - Coordination logic embedded in model reasoning
      - Model decides when to parallelize during generation
      - Spawns up to 100 subagents internally
      - Trained via PARL (Parallel-Agent Reinforcement Learning)
      - Critical Steps metric rewards parallelization

      Trade-offs documented:
      - SDK: High control, explicit debugging, portable across models
      - Swarm: Autonomous parallelization, lower overhead, model-specific

      Performance: Kimi K2.5 achieves 3-4.5× speedup (80% runtime reduction)
      on parallelizable tasks via model-native swarm.

      When to use each:
      - SDK: Deterministic workflows, explicit control required, model switching
      - Swarm: Dynamic parallelization, trust model decisions, high speedup potential

      This represents architectural shift from application-layer orchestration
      to model-capability orchestration. Future frontier models may adopt similar.
    evidence: chapters/3-model/4-multi-model-architectures.md#model-native-swarm-orchestration
    cross_references:
      - chapters/6-patterns/3-orchestrator-pattern.md#sdk-orchestration-vs-model-native-swarm
    timestamp: 2026-01-30

  teammatetool_coordination_pattern:
    name: TeammateTool - Native Multi-Agent Coordination
    context: Claude Code's hidden coordination layer beyond Task tool
    discovered: 2026-01-30 (commit de68e9f)
    implementation: |
      TeammateTool provides coordination primitives beyond Task's spawn-wait:

      **13 Operations:**
      - Spawn: Create teammates with role definitions
      - Join: Wait for specific teammates (not all)
      - Write: Send message to teammate's inbox
      - Broadcast: Send message to all teammates
      - Plan Approval: Human-in-the-loop gate
      - Shutdown: Graceful team termination
      - List/Status: Enumerate/query active teammates

      **File-Based Messaging:**
      - Location: ~/.claude/teams/{name}/inboxes/
      - Each teammate has inbox directory
      - Write file = send message (observable state)
      - Enables debugging, persistence, simple semantics

      **Five Coordination Patterns:**
      1. Leader-Worker: Spawn N workers, join all
      2. Swarm: Workers coordinate via broadcast
      3. Pipeline: Sequential handoffs with Write
      4. Council: Multiple perspectives, synthesis phase
      5. Plan Approval: Explicit human gate

      **Task vs TeammateTool:**
      - Task: Simple delegation (spawn, wait, return)
      - TeammateTool: Full coordination (messaging, selective waiting, approval gates)

      **Current Status:**
      - Server-side gated (requires CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1)
      - Official feature flag via environment variable
      - Production-ready code, controlled rollout
      - Aligns with Claude Agent SDK strategic direction
      - Documentation: https://code.claude.com/docs/en/agent-teams

      **When to Use:**
      - Use Task: Simple delegation, official support, minimal complexity
      - Use TeammateTool: Inter-agent messaging, selective joins, human approval gates

      Connection to patterns:
      - Plan Approval operation = built-in plan→build→improve cycle
      - File-based messaging = context isolation without pollution
      - Nesting: Unknown if teammates can spawn nested teams
    evidence: chapters/9-practitioner-toolkit/1-claude-code.md#teammatetool-native-multi-agent-coordination-hidden
    cross_references:
      - chapters/4-context/4-multi-agent-context.md (message passing pattern)
      - chapters/6-patterns/3-orchestrator-pattern.md (coordination primitives)
    timestamp: 2026-01-30

  expert_swarm_pattern:
    name: Expert Swarm Pattern - Domain Expertise + Parallel Execution
    context: Combining expert domain knowledge inheritance with swarm-scale parallelism
    discovered: 2026-02-02 (commit a1d5942)
    implementation: |
      Expert Swarm resolves orchestration tension: generic coordinators achieve
      parallelism but lack domain context; domain experts maintain consistency
      but execute sequentially.

      **Core Innovation: Expertise Inheritance via Path-Passing**
      Workers receive EXPERTISE_PATH (not copied content):
      ```
      EXPERTISE_PATH: /path/to/domain/expertise.yaml
      Read this file and apply relevant patterns.
      Focus on: Implementation Standards, Voice Patterns
      ```

      **Key Elements:**
      1. Expert as orchestrator - existing domain expert acts as lead
      2. Narrow workers - ephemeral agents spawned for single tasks
      3. Path-passing protocol - single source of truth (prevents context bloat)
      4. Learning separation - workers execute, improve agent analyzes post-swarm
      5. Single-message parallelism - all workers spawn in ONE message

      **Communication Mechanisms:**
      - Spec-as-artifact: Orchestrator writes spec file, workers read it
      - TeammateTool messaging: Write/Broadcast for coordination (when available)
      - No context passing between workers (isolation maintained)

      **Production Evidence (commit 20500f1):**
      - 10 parallel agents: 3,082 lines across 20 files in ~4 minutes
      - 10× speedup over sequential execution (~40 min → ~4 min)
      - Zero voice drift: All entries followed structure standards
      - Token economics: 750-line expertise.yaml = ~3K tokens per worker (manageable at 10 workers = 30K tokens)

      **Why Path-Passing vs Context Copying:**
      - Keeps orchestrator context clean (no 500-750 line pollution per worker)
      - Single source of truth (updates propagate to future workers)
      - Scales to 10+ workers without context explosion
      - Workers selectively read relevant sections

      **Learning Separation Rationale:**
      Allowing parallel workers to update expertise.yaml creates race conditions:
      Worker 1 and 2 read version A → both update → one overwrites other's learnings.
      Solution: Workers read-only access → swarm completes → improve agent analyzes
      all changes once → updates expertise → next swarm benefits.

      **Decision Framework:**
      Use Expert Swarm when:
      - Multiple independent tasks within single domain
      - Expertise.yaml exists (500-750 lines) and well-documented
      - Quality consistency valued (voice drift costly)
      - Scale exceeds single-agent capacity (10+ similar tasks)

      Don't use when:
      - Simple single-file changes (overhead exceeds benefit)
      - Tasks tightly coupled (sequential dependencies)
      - Domain expertise not yet codified
      - Cross-domain work (use multi-expert council instead)

      **Size Governance:**
      Target 750 lines for expertise.yaml to prevent token bloat when inherited.
      A 2,000-line expertise would cost 8K tokens per worker (unsustainable).

      **Coordination Patterns:**
      - Leader-Worker (default): Expert lead + narrow workers
      - Council: Multiple domain experts analyzing independently

      **Limitations:**
      - Flat architecture only (Claude Code nesting unreliable)
      - TeammateTool gated (rely on spec-as-artifact until GA)
      - Expertise synchronization requires governance
      - Token overhead: 3K per worker (30K for 10 workers)
    evidence: chapters/6-patterns/8-expert-swarm-pattern.md
    cross_references:
      - chapters/6-patterns/2-self-improving-experts.md (expertise evolution)
      - chapters/4-context/4-multi-agent-context.md (path-passing protocol)
      - .claude/commands/do-swarm.md (implementation)
    timestamp: 2026-02-02

  do_swarm_direct_orchestration:
    name: /do-swarm Direct Orchestration Pattern
    context: TeammateTool coordination at command level, not subagent
    discovered: 2026-02-02 (commit a1d5942)
    implementation: |
      /do-swarm command orchestrates TeammateTool swarms directly without
      spawning coordinator agent. This avoids nested subagent issues while
      enabling full TeammateTool primitives.

      **Architecture:**
      /do-swarm → YOU are team leader → spawn teammates → coordinate → synthesize

      Contrast with /do:
      - /do: Orchestrates via Task tool (spawn plan→build→improve)
      - /do-swarm: Orchestrates via Teammate operations (spawn, message, join)

      **Workflow:**
      1. Create team: Teammate(operation="spawnTeam")
      2. Spawn lead + workers: Task(team_name=X, name=Y) in single message
      3. Coordinate: SendMessage (direct/broadcast)
      4. Receive results: Automatic delivery via messaging
      5. Synthesize: Aggregate worker outputs
      6. Cleanup: Teammate(operation="cleanup")

      **Canonical Prompting Format (Variance Reduction):**
      Every teammate prompt follows structure:
      - ROLE: You are a {role} specializing in {capability}
      - CONTEXT: EXPERTISE_PATH, TEAM, LEADER/WORKERS
      - TASK: Clear, specific deliverable
      - CONSTRAINTS: Tools, completion signals, messaging protocol
      - OUTPUT FORMAT: Structured sections (Status, Files, Summary)

      Forbidden patterns documented:
      - Meta-commentary openers ("Based on...", "I have created...")
      - Negative constraints ("Never X" causes pink elephant effect)
      - Vague instructions ("Be thorough")
      - Unbounded scope ("Research everything")

      **Role-Based Tool Access:**
      | Role | Allowed Tools | Forbidden |
      |------|---------------|-----------|
      | Lead | Read, Glob, Grep, SendMessage | Write, Edit (delegates) |
      | Worker | Read, Write, Edit, SendMessage | Task (no sub-spawning) |
      | Expert (Council) | Read, Glob, Grep, WebSearch | Write (analysis only) |
      | Scout | Read, Glob, Grep | Write, Edit, Task |

      **Shutdown Optimization:**
      Full shutdown ceremony (SendMessage shutdown request + wait + cleanup)
      adds 3-4 conversation turns. For quick research swarms, skip shutdown—
      teammates timeout after ~5 min naturally.

      **When to Use /do-swarm vs /do:**
      - /do: Sequential workflows (plan→build→improve), simple delegation
      - /do-swarm: Parallel coordination with inter-agent messaging, multiple
        expert perspectives, complex multi-agent workflows

      **Requirements:**
      TeammateTool access (server-side gated, requires CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1 environment variable)
    evidence: .claude/commands/do-swarm.md
    cross_references:
      - chapters/6-patterns/8-expert-swarm-pattern.md (pattern documentation)
      - chapters/6-patterns/3-orchestrator-pattern.md (orchestration principles)
    timestamp: 2026-02-02

  canonical_teammate_prompting:
    name: Canonical Teammate Prompting Format for Swarm Consistency
    context: Reducing variance in parallel swarm execution via structured prompts
    discovered: 2026-02-02 (commit 75a4962)
    implementation: |
      Variance in teammate prompts causes inconsistent swarm behavior. Canonical
      format enforces structure across all parallel agents:

      **Required Sections:**
      1. ROLE: Identity + focus (one sentence)
      2. CONTEXT: EXPERTISE_PATH, TEAM, relationships
      3. TASK: Specific deliverable (not open-ended)
      4. CONSTRAINTS: Tools, completion signals, messaging
      5. OUTPUT FORMAT: Structured sections (prevents meta-commentary)

      **Forbidden Patterns (Documented):**
      | Category | Forbidden | Correct Alternative |
      |----------|-----------|-------------------|
      | Openers | "Based on...", "I have created..." | Start with content directly |
      | Constraints | "Never modify files without reading" | "Read file contents before editing" |
      | Instructions | "Be thorough" | "Cover these 3 scenarios: {list}" |
      | Scope | "Research everything about X" | "Research X from {3 sources}" |

      **Rationale:**
      - Negative constraints cause "pink elephant" effect (model focuses on prohibited action)
      - Meta-commentary wastes context and dilutes focus
      - Vague instructions lead to interpretation variance
      - Unbounded scope causes inconsistent task boundaries

      **Validation Levels:**
      Specify validation explicitly to prevent inconsistent quality:
      - Level 1 (Quick): Syntax check only (docs, comments)
      - Level 2 (Standard): Run tests, verify no regressions (features)
      - Level 3 (Critical): Full test suite + manual verification (API, auth)

      **Role-Based Tool Access:**
      Explicit tool constraints prevent confusion and security issues.
      Lead agents coordinate (no Write); workers implement (no Task).

      **Output Format Enforcement:**
      End every prompt with: "CRITICAL: Use this exact format. No preamble."
      Prevents "I have completed..." and other meta-commentary that pollutes
      orchestrator context during synthesis.

      **Production Impact:**
      10-agent swarm (commit 20500f1) with canonical prompting: zero voice drift,
      consistent structure across all 20 files. Prior swarms without canonical
      format showed 15-20% variance in section structure and output style.
    evidence: .claude/commands/do-swarm.md#teammate-prompting-format
    cross_references:
      - chapters/6-patterns/8-expert-swarm-pattern.md
    timestamp: 2026-02-02

potential_enhancements:
  - enhancement: Automated spec file cleanup after successful build
    rationale: Prevent .claude/plans/ from accumulating stale specs
    effort: low
    timestamp: 2025-12-26

  - enhancement: Parallelism linting - warn if independent Tasks in separate messages
    rationale: Catch accidental serialization
    effort: medium
    timestamp: 2025-12-26

  - enhancement: /do orchestration testing framework
    rationale: Verify classification logic, routing tables, approval gates
    effort: medium
    timestamp: 2025-12-26

stability:
  oscillation_detection:
    rule: |
      IF entry E1 at T1 contradicts E0 at T0
      AND entry E2 at T2 contradicts E1
      THEN oscillation detected
    resolution: |
      Preserve both with conflict marker
      Escalate to human
    detected_oscillations: []

  convergence_indicators:
    insight_rate_trend: increasing
    contradiction_count: 0
    last_reviewed: 2026-02-02
    notes: |
      Domain stabilizing after pruning (940→464 lines in cb89c17).
      Key patterns validated: flat orchestration, single-message parallelism,
      4-agent expert pattern, approval gates, expertise size governance.

      New learnings this cycle: 4 patterns (expert swarm, /do-swarm direct orchestration,
      canonical prompting format, expertise inheritance protocol)
      Cross-domain contributions: 3 patterns (expertise inheritance, learning separation,
      canonical prompting - apply to any swarm coordination domain)

      ELA Component 2 implemented (orchestration trace logging).
      ELA Component 3 implemented (cross-domain registry).
      Observability infrastructure enables self-improving orchestration.

      Size health: 663→946 lines (+283 from this improvement cycle, approaching WARNING threshold)
      Note: Next improve cycle should assess consolidation opportunities - expertise
      inheritance pattern may subsume earlier delegation patterns.

      Major architectural addition:
      - Expert Swarm Pattern bridges generic orchestration and domain expertise
      - /do-swarm enables TeammateTool swarms at command level (no coordinator nesting)
      - Production validated: 10× speedup, zero voice drift across 20 files
      - Canonical prompting format reduces variance in parallel swarm execution
      - Path-passing protocol solves context bloat problem (750 lines → 3K tokens vs copying)

      Architectural evolution detected:
      - Model-native swarm represents shift from SDK to model-capability orchestration
      - TeammateTool indicates Anthropic's strategic direction toward richer coordination
      - Expert Swarm combines SDK orchestration with domain expertise accumulation
      - All three patterns complement (not replace) existing orchestration approaches
