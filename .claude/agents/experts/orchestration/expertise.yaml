# Workflow Orchestration Expertise
# Target: 600-700 lines | Domain: Operational knowledge for multi-agent coordination

overview:
  description: |
    Workflow orchestration for multi-agent systems—single-message parallelism,
    dependency batching, phase gating, spec-as-artifact pattern, and coordinator
    vs worker tool sets. This expertise enables efficient parallel execution and
    clean workflow coordination.
  scope: |
    Covers Task tool parallelism patterns, dependency management, orchestrator
    design, spec file patterns, and tool selection by role. Does NOT cover
    general scheduling or traditional workflow engines. Focuses on Claude Code
    and SDK-level orchestration patterns.
  rationale: |
    Poor orchestration leads to sequential bottlenecks, race conditions, and
    fragile workflows. Correct parallelism patterns dramatically reduce latency.
    Single-message parallelism is the make-or-break pattern most practitioners miss.

core_implementation:
  primary_files:
    - path: .claude/commands/do.md
      purpose: Direct orchestration of expert agents - plan→approval→build→improve pattern
    - path: .claude/skills/orchestrating-knowledge-workflows/SKILL.md
      purpose: Workflow templates (formerly coordinators, converted to skills in commit 353d576)
    - path: chapters/6-patterns/3-orchestrator-pattern.md
      purpose: Orchestrator pattern documentation with single-message parallelism
    - path: chapters/7-practices/5-workflow-coordination.md
      purpose: Workflow coordination practices

  key_sections:
    - name: Single-Message Parallelism
      location: chapters/6-patterns/3-orchestrator-pattern.md#single-message-parallelism
      summary: CRITICAL pattern - all parallel Task calls in ONE message
    - name: Context Isolation via Sub-Agents
      location: chapters/6-patterns/3-orchestrator-pattern.md#context-isolation-via-sub-agents
      summary: Why delegation maintains clean orchestrator context
    - name: Capability Minimization
      location: chapters/6-patterns/3-orchestrator-pattern.md#capability-minimization
      summary: Tool restriction patterns for subagents

key_operations:
  single_message_parallelism:
    name: Execute Independent Tasks in Parallel (Single Message)
    description: Run all non-dependent Task calls in ONE message for true concurrency
    when_to_use: CRITICAL - Multiple independent operations needed
    approach: |
      1. Identify independent operations (no data dependencies between them)
      2. Make ALL Task calls in a single response message
      3. Wait for ALL to complete before proceeding
      4. NEVER split into multiple messages unless dependencies exist

      Why: 10 agents in parallel ≈ 1 agent time vs 10× longer if serialized
    examples:
      - scenario: Research spawning 3 independent workers
        implementation: "Task(docs), Task(blogs), Task(examples) in ONE message"
      - scenario: Sequential plan→build (dependency exists)
        implementation: "Message 1: Task(plan). Wait. Message 2: Task(build)"

  dependency_batching:
    name: Batch Operations by Dependency Layer
    description: Group operations that can run together, gate on dependencies
    when_to_use: Complex workflows with partial dependencies
    approach: |
      1. Map dependency graph
      2. Identify layers (L0: no deps, L1: depends on L0, etc.)
      3. Execute each layer in single message (parallel within layer)
      4. Wait for layer completion before next layer
    examples:
      - scenario: Parallel scouts → synthesis → parallel builds
        layers: "L0: [scout-a, scout-b, scout-c]. L1: [synth]. L2: [build-1, build-2]"

  spec_as_artifact:
    name: Write Spec File, Workers Read It
    description: Coordinator writes spec to file, spawned agents read it
    when_to_use: Passing complex context between agents
    approach: |
      1. Coordinator writes spec to .claude/.cache/specs/<domain>/<slug>.md
      2. Spawns worker with: Task(build-agent, "PATH_TO_SPEC: <path>")
      3. Worker reads spec file (not passed inline)

      Benefits: Decouples spec from execution, enables resume, auditable artifact
    examples:
      - scenario: Knowledge plan→build flow
        implementation: "Plan writes spec. Spawns: Task(build, PATH_TO_SPEC)"

  context_isolation:
    name: Use Sub-Agents for Context Hygiene
    description: Deploy fresh context windows for search/analysis operations
    when_to_use: Orchestrator needs synthesized information, not raw data
    approach: |
      Sub-agents absorb raw data, return summaries:
      - Scout: "Found 47 files in 3 modules" (not 47 paths)
      - Grep: "Pattern in 12 locations, primarily validation" (not 12 matches)

      Mental model: Sub-agents are expensive, disposable context buffers
    examples:
      - scenario: Orchestrator needs codebase overview
        implementation: "Task(scout). Scout absorbs paths. Returns: synthesis only."

decision_trees:
  architecture_decision:
    name: Flat vs Nested Orchestration
    entry_point: How many orchestration layers needed?
    branches:
      - condition: Entry point needs multi-phase workflow
        action: Flat - entry point spawns workers directly
        rationale: Avoids nested subagent limitation (agent→Task→agent→Task unreliable)
      - condition: Need reusable workflow templates
        action: Create skill (not coordinator agent)
        rationale: Skills provide templates without spawning complexity
      - condition: Multiple independent workers
        action: Spawn all in parallel from entry point (single message)
    evidence: commit 353d576 - flatten architecture
    timestamp: 2025-12-26

  parallelism_decision:
    name: Parallelism Decision Tree
    entry_point: Are operations independent?
    branches:
      - condition: No dependencies
        action: ALL Task calls in ONE message
      - condition: Operation B depends on A
        action: "Msg 1: Task(A). Wait. Msg 2: Task(B)"
      - condition: Complex dependency graph
        action: Batch by layer, one message per layer

  tool_selection_by_role:
    name: Tool Selection for Agent Role
    entry_point: What is the agent's primary function?
    branches:
      - condition: Coordination/orchestration
        action: Task, Read, Grep, Glob, AskUserQuestion (NO Write)
      - condition: Implementation/building
        action: Read, Write, Edit, Grep, Glob (NO Task)
      - condition: Exploration/scouting
        action: Read, Glob, Grep only (read-only)

patterns:
  flat_orchestration_pattern:
    name: Flat Orchestration (Direct Expert Agent Spawning)
    context: Avoiding nested subagent limitations by flattening hierarchy
    implementation: |
      OLD (nested, broken): /do → coordinator → expert (Task→Task)
      NEW (flat, working): /do → expert (single Task layer)

      /do directly orchestrates: classify → spawn plan → approve → spawn build → spawn improve
    evidence: commit 353d576 - deleted .claude/agents/coordinators/
    timestamp: 2025-12-26

  fan_out_fan_in:
    name: Fan-Out Fan-In (Parallel Workers, Single Aggregator)
    context: Multiple independent workers, aggregate results
    implementation: |
      1. Fan-out: Spawn N workers in single message
      2. Wait: All workers complete
      3. Fan-in: Aggregate into unified output
    real_examples:
      - location: .claude/skills/researching-external-sources/SKILL.md
        note: Spawn 3 parallel researchers

  phase_gating_pattern:
    name: Phase Gating (Plan → Approve → Build → Review)
    context: Workflows requiring human approval between phases
    implementation: |
      1. Spawn plan → wait for spec
      2. AskUserQuestion("Approve?") → gate
      3. Spawn build with spec path
      4. Spawn improve if changes made
    evidence: .claude/commands/do.md lines 139-144
    timestamp: 2025-12-26

  4_agent_domain_pattern:
    name: 4-Agent Domain Expert Pattern (Plan/Build/Improve/Question)
    context: Organizing domain expertise into standardized agent roles
    implementation: |
      Each expert domain gets 4 specialized agents:
      1. plan-agent: Creates specs → .claude/.cache/specs/<domain>/
      2. build-agent: Implements from spec (NO Task tool)
      3. improve-agent: Learns from changes, updates expertise.yaml
      4. question-agent: Answers domain questions

      In flat architecture: /do spawns plan→build→improve directly (no coordinator layer)
    real_examples:
      - location: .claude/agents/experts/knowledge/
        note: Full 4-agent pattern
      - location: .claude/agents/experts/github/
        note: Added in commit 35a871a
    timestamp: 2025-12-26

cross_domain_inheritance: []

best_practices:
  - category: Architecture
    practices:
      - practice: Prefer flat orchestration - entry point spawns workers directly
        evidence: commit 353d576 - flatten to avoid nested subagent issues
        timestamp: 2025-12-26
      - practice: Convert coordinators to skills (workflow templates)
        evidence: .claude/skills/*-workflows/ - former coordinators
        timestamp: 2025-12-26
      - practice: Standardize color assignments (plan=yellow, build=green, improve=purple, question=cyan)
        evidence: commit 89fbbf9 - 49 agents across 12 domains
        timestamp: 2025-12-26
      - practice: Use /do as universal orchestrator (not multiple coordinators)
        evidence: commit 353d576 - single orchestration point
        timestamp: 2025-12-26
      - practice: NEVER use colons in agent description frontmatter (Expects USER_PROMPT, not Expects colon USER_PROMPT)
        evidence: commit b6a2b47 - fixed 38 agents silently failing discovery due to colon
        rationale: Colons in description values cause silent agent discovery failures
        timestamp: 2026-01-17

  - category: Parallelism
    practices:
      - practice: CRITICAL - All independent Task calls in ONE message
        evidence: chapters/6-patterns/3-orchestrator-pattern.md
        timestamp: 2025-12-26
      - practice: Wait for layer completion before next dependency layer
        evidence: .claude/commands/do.md sequential phase execution
        timestamp: 2025-12-26

  - category: Tool Selection
    practices:
      - practice: Entry orchestrators get Task + Read + Grep + Glob + AskUserQuestion (no Write)
        note: Orchestrators delegate implementation
      - practice: Workers get Read + Write + Edit + Grep + Glob (no Task)
        note: Workers implement, don't spawn - prevents nested issues
      - practice: Scouts get Read + Glob + Grep only (read-only)
      - practice: Plan agents get Read + Write + Grep + Glob (Write for spec caching only)
      - practice: Operational agents (git, deployment) need Bash for commands
        evidence: github-build-agent.md uses Bash with safety protocols
        timestamp: 2025-12-26
      - practice: Improve agents get Bash for usage analysis (git log, gh pr list)
        evidence: github-improve-agent.md analyzes git history
        timestamp: 2025-12-26

  - category: Spec Patterns
    practices:
      - practice: Spec files in .claude/.cache/specs/<domain>/
      - practice: Pass file path to worker, not spec content inline
      - practice: Spec enables resume with --build-only flag

  - category: Context Hygiene
    practices:
      - practice: Sub-agents return synthesis, not raw output
      - practice: Orchestrator context should contain summaries, not raw data

  - category: Expertise Governance
    practices:
      - practice: Enforce expertise.yaml size limits - HARD LIMIT 1000 lines, TARGET 750, WARNING 900
        evidence: commit cb89c17 - pruned 12 domains from 10,425→6,537 lines (-37%)
        rationale: Prevents unbounded accumulation, degraded maintainability, duplicate patterns
        timestamp: 2025-12-28
      - practice: Prune tactical entries >14 days old when approaching size limits
        evidence: Cross-domain pattern expertise-size-governance
        timestamp: 2025-12-28
      - practice: Consolidate duplicate patterns and reduce examples to 2-3 max
        evidence: orchestration domain pruned from 940→464 lines in cb89c17
        timestamp: 2025-12-28

  - category: Error Handling
    practices:
      - practice: Graceful degradation - continue with available analyses if expert fails
        evidence: chapters/6-patterns/3-orchestrator-pattern.md#error-handling
        timestamp: 2025-12-26
      - practice: Commit successful changes before reporting failures
      - practice: Isolated failure in parallel execution (one failure doesn't cascade)
        evidence: research-coordinator-agent.md lines 502-506
        timestamp: 2025-12-26
      - practice: Improve stage is optional - workflow succeeds if build succeeds
        timestamp: 2025-12-26

  - category: Sequential vs Parallel Coordination
    practices:
      - practice: Plan→Build→Improve runs sequentially (dependency chain)
        evidence: .claude/commands/do.md lines 134-158
        timestamp: 2025-12-26
      - practice: Multi-source research runs in parallel (fan-out/fan-in)
        evidence: .claude/skills/researching-external-sources/SKILL.md
        timestamp: 2025-12-26
      - practice: Always wait for Task completion before proceeding
        evidence: .claude/commands/do.md Rule 3 (lines 110-126)
        timestamp: 2025-12-26

anti_patterns:
  frontmatter_colon_usage:
    name: Using Colons in Agent Description Frontmatter Values
    why_problematic: |
      Colons in YAML frontmatter values cause silent parsing failures.

      Common pattern: "description: Plans X. Expects: USER_PROMPT"
      Problem: Second colon breaks YAML parsing → agent not discovered
      Detection: Agent file exists but Claude Code can't spawn it (silent failure)

      Blast radius: Affects ALL agents with this pattern (38 in b6a2b47)
      Impact: Workflows break silently, users assume agents don't exist
    resolution: |
      Remove ALL colons from frontmatter values:
      - BEFORE: "Expects: USER_PROMPT"
      - AFTER: "Expects USER_PROMPT"

      Detection command: grep -r "description:.*Expects:" .claude/agents/
      Validation: Claude Code agent discovery test
    evidence: commit b6a2b47 - 38 agents fixed
    timestamp: 2026-01-17

  coordinator_proliferation:
    name: Creating Specialized Coordinator per Workflow Type
    why_problematic: |
      Deprecated pattern: Create separate coordinator agents (book, knowledge, research, review).

      Problems:
      1. Nested subagent spawning unreliable (coordinator→Task→expert broken)
      2. Coordinator logic duplicates across workflows
      3. Hard to discover which coordinator to use
      4. Each coordinator adds 300-600 lines
      5. Inconsistent approval gates
    resolution: |
      Flatten to single /do orchestrator:
      - /do classifies → routes to domain
      - /do orchestrates plan→approve→build→improve directly
      - Workflows become skills (templates, not agents)

      Result: 4 coordinators (1847 lines) → 1 orchestrator (710 lines) + 4 skill templates
    evidence: commit 353d576 - deleted .claude/agents/coordinators/
    timestamp: 2025-12-26

  accidental_serialization:
    name: Splitting Independent Task Calls Across Messages
    why_problematic: |
      Most common error: Spawn 3 independent agents across 3 messages.
      Result: Sequential execution (3× latency) instead of parallel (1× latency).
    resolution: |
      CRITICAL discipline - all independent Task calls in ONE message:
      Task(researcher-a), Task(researcher-b), Task(researcher-c) in same response
    evidence: chapters/6-patterns/3-orchestrator-pattern.md lines 39-56
    timestamp: 2025-12-26

  premature_exit_in_async_contexts:
    name: Not Waiting for Task Completion Before Reporting
    why_problematic: |
      In --print mode and async contexts, exiting before subagents complete loses work.
      User sees "complete" but no results.
    resolution: |
      Always wait for Task completion → extract outputs → synthesize → report
      Rule: Wait → Collect → Synthesize → Report (never exit early)
    evidence: .claude/commands/do.md Rule 3 (lines 110-126)
    timestamp: 2025-12-26

known_issues:
  - issue: Nested subagent spawning (agent→Task→agent→Task) unreliable
    workaround: Flatten architecture - top-level command orchestrates directly
    status: architectural-limitation (resolved via flatten pattern)
    timestamp: 2025-12-26
    evidence: commit 353d576

  - issue: Task tool parallelism requires single message discipline
    workaround: Explicit instruction in prompts to emit all parallel calls in one response
    status: open
    timestamp: 2025-12-26

  - issue: Spec file cleanup not automated
    workaround: Manual cleanup or periodic purge of .claude/.cache/specs/
    status: open
    timestamp: 2025-12-26

  - issue: CLI-level tool restrictions apply uniformly
    workaround: Explicit tool declarations in frontmatter, behavioral enforcement via prompts
    status: documented-limitation
    timestamp: 2025-12-26

patterns_discovered_in_recent_work:
  agent_description_frontmatter_safety:
    name: Agent Description Frontmatter Safety (Colon Prohibition)
    context: Preventing silent agent discovery failures
    discovered: 2026-01-17 (commit b6a2b47)
    implementation: |
      Agent frontmatter description field MUST NOT contain colons in values.

      INCORRECT: "description: Plans X. Expects: USER_PROMPT"
      CORRECT: "description: Plans X. Expects USER_PROMPT"

      Rationale: Colons in description values cause YAML parsing errors that
      fail silently - agent files exist but Claude Code can't discover them.

      Detection: Check all agent files with grep for "description:.*Expects:"
      Fix: Remove colons after "Expects", use spaces instead

      Applies to: ALL agent frontmatter fields (description, tools, model, etc.)

      Blast radius: 38 agents across 12 expert domains affected in b6a2b47
    evidence: commit b6a2b47 - 38 agent files fixed simultaneously
    timestamp: 2026-01-17

  orchestration_trace_logging_pattern:
    name: Orchestration Execution Trace Logging
    context: Observability for self-improving orchestration (ELA Component 2)
    discovered: 2025-12-27
    implementation: |
      PostToolUse hook captures execution traces when Task tool invoked.

      Data captured per Task:
      - Agent metadata: name, type, file path, phase, domain
      - Execution metrics: latency_ms, success/failure, error_type
      - Context metrics: context_tokens, output_tokens, total_tokens
      - Hierarchy: session_id, parent_session_id, agent_depth
      - Orchestration: spec_path, description

      Output: .claude/.cache/orchestration-traces.jsonl (append-only)

      Analysis opportunities:
      - Single-message parallelism adherence (count concurrent Task calls)
      - Phase timing distribution (plan_avg_ms, build_avg_ms, improve_avg_ms)
      - Approval gate effectiveness (rejection rate)
      - Context pollution trends (orchestrator context size growth)

      Enables: do-management-improve-agent to analyze /do routing strategy
    evidence: .claude/hooks/orchestration_trace_logger.py - 273 lines
    timestamp: 2025-12-27

  cross_domain_learning_registry_pattern:
    name: Cross-Domain Expertise Propagation via Shared Registry
    context: Enable pattern sharing across 12 expert domains (ELA Component 3)
    discovered: 2025-12-27
    implementation: |
      Shared registry at .claude/agents/experts/.shared/observations.yaml

      Structure:
      - cross_domain_patterns: pattern name, source, observation, applicability, evidence
      - failed_adoptions: pattern, attempted_in, reason, lesson

      Contribution protocol:
      1. After updating domain expertise.yaml
      2. Check: Does this pattern apply beyond this domain?
      3. If yes: Append to observations.yaml with applicability list
      4. If failed: Document why, extract meta-learning

      Governance: Decentralized - any improve agent can contribute
      Validation: Domains mark patterns as validated via cross_domain_inheritance
    evidence: .claude/agents/experts/.shared/observations.yaml - 138 lines
    timestamp: 2025-12-27

  color_standardization_pattern:
    name: Semantic Color Coding for 4-Agent Expert Domains
    context: Visual discoverability across all expert domains
    discovered: 2025-12-26 (commit 89fbbf9)
    implementation: |
      Consistent color scheme:
      - plan-agent: yellow (analysis)
      - build-agent: green (creation)
      - improve-agent: purple (review)
      - question-agent: cyan (advisory)

      Applied to 49 agents across 12 domains.
      Visual benefit: Instant role identification by color.
    adoption: Apply to all future expert domains
    timestamp: 2025-12-26

  universal_orchestrator_pattern:
    name: Universal /do Command (Single Orchestration Point)
    context: Eliminating coordinator proliferation
    discovered: 2025-12-26 (commit 353d576)
    implementation: |
      /do handles all orchestration:
      1. Classify requirement → identify domain
      2. Route to expert domain agents
      3. Orchestrate plan→approve→build→improve
      4. Handle approval gates via AskUserQuestion
      5. Synthesize results

      Deleted 4 specialized coordinators, converted to skills.
    evidence: commit 353d576 - deleted .claude/agents/coordinators/
    timestamp: 2025-12-26

  approval_gate_pattern:
    name: User Approval Between Plan and Build
    context: Preventing unwanted implementations via explicit checkpoints
    discovered: 2025-12-26
    implementation: |
      Plan creates spec → /do shows spec path → user approves → build executes.

      Using AskUserQuestion at /do level:
      - If user declines: Report spec location, suggest resume later
      - If plan fails: Report error, cannot proceed
      - If build fails: Preserve spec for retry, skip improve
    evidence: .claude/commands/do.md lines 139-148
    adoption: All implementation workflows should include approval gates
    timestamp: 2025-12-26

  delta_based_monitoring_pattern:
    name: Delta-Based Changelog Monitoring
    context: Efficient external dependency tracking without redundant re-analysis
    discovered: 2026-01-11 (commit d69ef22)
    implementation: |
      Monitor external changelog updates via state tracking for delta fetch:

      State File: .claude/.cache/changelog-state/<source>.json
      Schema: {source, last_version, last_checked, url, notes}

      Workflow:
      1. Check state file existence
      2. If missing: Full fetch (baseline)
      3. If present: Delta fetch (versions > last_version)
      4. Analyze changes: features, breaking changes, security
      5. Map cross-domain impact (which chapters/config affected)
      6. Update state file with latest version

      Orchestration Layer: /do routes to research-build-agent
      Cross-domain impact: Single changelog → multiple expert domains
      Example: Claude Code 2.1.0-2.1.4 → 7 updates across 3 chapters

      Enables: Proactive book/config updates without manual tracking
    evidence: commit d69ef22 - Claude Code 2.1.5-2.1.9 sync via state file
    real_examples:
      - location: .claude/.cache/changelog-state/claude-code.json
        note: Tracks version progression for delta fetch
    timestamp: 2026-01-11

  swarm_orchestration_pattern:
    name: Model-Native Swarm Orchestration vs SDK Orchestration
    context: Two architectural approaches to multi-agent coordination
    discovered: 2026-01-30 (commit de68e9f)
    implementation: |
      Orchestration can happen at two different layers:

      **SDK Orchestration (Claude Code, LangGraph, AutoGen):**
      - Coordination logic in external framework code
      - Explicit Task/API calls to spawn subagents
      - Framework handles waiting, synthesis, error handling
      - Developer writes coordination code
      - Example: /do spawns plan→build→improve via Task calls

      **Model-Native Swarm (Kimi K2.5):**
      - Coordination logic embedded in model reasoning
      - Model decides when to parallelize during generation
      - Spawns up to 100 subagents internally
      - Trained via PARL (Parallel-Agent Reinforcement Learning)
      - Critical Steps metric rewards parallelization

      Trade-offs documented:
      - SDK: High control, explicit debugging, portable across models
      - Swarm: Autonomous parallelization, lower overhead, model-specific

      Performance: Kimi K2.5 achieves 3-4.5× speedup (80% runtime reduction)
      on parallelizable tasks via model-native swarm.

      When to use each:
      - SDK: Deterministic workflows, explicit control required, model switching
      - Swarm: Dynamic parallelization, trust model decisions, high speedup potential

      This represents architectural shift from application-layer orchestration
      to model-capability orchestration. Future frontier models may adopt similar.
    evidence: chapters/3-model/4-multi-model-architectures.md#model-native-swarm-orchestration
    cross_references:
      - chapters/6-patterns/3-orchestrator-pattern.md#sdk-orchestration-vs-model-native-swarm
    timestamp: 2026-01-30

  teammatetool_coordination_pattern:
    name: TeammateTool - Native Multi-Agent Coordination
    context: Claude Code's hidden coordination layer beyond Task tool
    discovered: 2026-01-30 (commit de68e9f)
    implementation: |
      TeammateTool provides coordination primitives beyond Task's spawn-wait:

      **13 Operations:**
      - Spawn: Create teammates with role definitions
      - Join: Wait for specific teammates (not all)
      - Write: Send message to teammate's inbox
      - Broadcast: Send message to all teammates
      - Plan Approval: Human-in-the-loop gate
      - Shutdown: Graceful team termination
      - List/Status: Enumerate/query active teammates

      **File-Based Messaging:**
      - Location: ~/.claude/teams/{name}/inboxes/
      - Each teammate has inbox directory
      - Write file = send message (observable state)
      - Enables debugging, persistence, simple semantics

      **Five Coordination Patterns:**
      1. Leader-Worker: Spawn N workers, join all
      2. Swarm: Workers coordinate via broadcast
      3. Pipeline: Sequential handoffs with Write
      4. Council: Multiple perspectives, synthesis phase
      5. Plan Approval: Explicit human gate

      **Task vs TeammateTool:**
      - Task: Simple delegation (spawn, wait, return)
      - TeammateTool: Full coordination (messaging, selective waiting, approval gates)

      **Current Status:**
      - Server-side gated (requires feature flags)
      - Unlockable via claude-sneakpeek
      - Production-ready code, controlled rollout
      - Aligns with Claude Agent SDK strategic direction

      **When to Use:**
      - Use Task: Simple delegation, official support, minimal complexity
      - Use TeammateTool: Inter-agent messaging, selective joins, human approval gates

      Connection to patterns:
      - Plan Approval operation = built-in plan→build→improve cycle
      - File-based messaging = context isolation without pollution
      - Nesting: Unknown if teammates can spawn nested teams
    evidence: chapters/9-practitioner-toolkit/1-claude-code.md#teammatetool-native-multi-agent-coordination-hidden
    cross_references:
      - chapters/4-context/4-multi-agent-context.md (message passing pattern)
      - chapters/6-patterns/3-orchestrator-pattern.md (coordination primitives)
    timestamp: 2026-01-30

potential_enhancements:
  - enhancement: Automated spec file cleanup after successful build
    rationale: Prevent .claude/plans/ from accumulating stale specs
    effort: low
    timestamp: 2025-12-26

  - enhancement: Parallelism linting - warn if independent Tasks in separate messages
    rationale: Catch accidental serialization
    effort: medium
    timestamp: 2025-12-26

  - enhancement: /do orchestration testing framework
    rationale: Verify classification logic, routing tables, approval gates
    effort: medium
    timestamp: 2025-12-26

stability:
  oscillation_detection:
    rule: |
      IF entry E1 at T1 contradicts E0 at T0
      AND entry E2 at T2 contradicts E1
      THEN oscillation detected
    resolution: |
      Preserve both with conflict marker
      Escalate to human
    detected_oscillations: []

  convergence_indicators:
    insight_rate_trend: stable
    contradiction_count: 0
    last_reviewed: 2026-01-30
    notes: |
      Domain stabilizing after pruning (940→464 lines in cb89c17).
      Key patterns validated: flat orchestration, single-message parallelism,
      4-agent expert pattern, approval gates, expertise size governance.

      New learnings this cycle: 2 patterns (swarm orchestration, TeammateTool coordination)
      Cross-domain contributions: 2 patterns (both apply to multi-model, context, tool-use domains)

      ELA Component 2 implemented (orchestration trace logging).
      ELA Component 3 implemented (cross-domain registry).
      Observability infrastructure enables self-improving orchestration.

      Size health: 517→663 lines (+146 from this improvement cycle, still under 750 target)

      Architectural evolution detected:
      - Model-native swarm represents shift from SDK to model-capability orchestration
      - TeammateTool indicates Anthropic's strategic direction toward richer coordination
      - Both patterns complement existing SDK orchestration (not replacements)
